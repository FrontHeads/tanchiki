# Единый стиль кода

1. [Зачем это нужно?](#зачем-это-нужно)
2. [Тесты](#как-пишем-тесты)
3. [Комментарии](#как-пишем-комментарии)
4. [Документация](#документация)
5. [Вёрстка](#вёрстка)
6. [DOM](#работа-с-dom)
7. [Импорты/экспорты](#импортыэкспорты)
8. [Typescript](#typescript)
9. [Архитектура](#архитектура)
10. [Нейминг](#нейминг)
11. [Убираем магию](#убираем-магию)
12. [Делаем код понятнее](#делаем-код-понятнее)
13. [React](#react)
14. [Redux](#redux)
 
## Зачем это нужно?

1. Это хорошие практики, к которым стоит привыкать. Их использование показывает высокую культуру кодинга. Хотя некоторые моменты являются холиварными.
2. Это сделает код понятнее для каждого из нас. 
3. Это упростит ревью: 
   - понятный код проверяется быстрее
   - будет меньше разногласий, т.к. всегда можно сослаться на этот файл.

Статья на тему: [зачем нужен единый стиль кода для команды?](https://doka.guide/js/code-style/)

### Как пишем тесты

Тесты пишет каждый сам за себя. 

По умолчанию задача считается закрытой только при наличии тестов, но возможны исключения если команда решит, что в тестах конкретной задачи нет необходимости (будем решать на собраниях).

Описание тестов пишем на английском, но не стесняемся в тестах оставлять комментарии на русском. 

Описание тестов должно начинаться с "it" или "should".

Одна из основных задач тестов - чтобы они были понятными. Непонятные замудрёные тесты - хуже чем никаких.

### Как пишем комментарии

"Хороший код не требует комментариев" - популярное мнение, с которым сложно спорить. Хороший код должен отлично отвечать на вопрос "Как это работает?", однако он далеко не всегда способен ответить на вопросы "Зачем?" и "Почему так?".

Если в коде используются какие-то нестандартные вещи, трюки, хаки - они **обязательно** должны быть прокомментированы. 

Сложные моменты в коде, которые отняли много времени при разработке тоже будет не лишним прокомментировать. 

Существует две нотации для комментариев:
1. ``// Какой-то текст комментария ``
2. ``/** Какой-то текст комментария */``

Преимущество стоит отдавать второму типу комментариев, поскольку они подхватываются IDE и в дальнейшем всплывают в виде подсказок при наведении курсора на прокомментированные сущности в коде.

### Документация

1. Создаем файл для описания чего-либо в папке docs

2. Добавляем ссылку на созданный файл в docs/README.md

   ``- [Название раздела](ИмяФайла.md) - Краткое описание.``

3. Пишем документацию. (Если необходимо добавить изображения создаем папку одноименную файлу)

### Вёрстка

- Используем [БЭМ](https://ru.bem.info/methodology/quick-start/).

### Работа с DOM
- [Работа с формами](https://doka.guide/js/deal-with-forms/). Обязательно используем тег ``<form>``. Событие для отправки формы - Submit, вешается на ``<form>``, а не событие Click навешанное на кнопку. 

### Импорты/экспорты
- [Импорты](https://doka.guide/js/modules/) - рекомендуется использовать именованные импорты, а не импорты по умолчанию (``default``). Эту рекомендацию видел в разных источниках, лучшее ее придерживаться.
- Используем реэкспорты. Т.е. во всех директориях создаем файл ``index.ts(x)`` в котором указываем все импорты внутри этой директории. Даже если там всего один импорт.

### Typescript
- Используем Type, а не Interface для определения типов.
- Локальные типы (которые требуются только в рамках одного компонента) храним в файле typings.ts(x) в директории компонента.
- Глобальные типы (которые требуются в нескольких компонентах) храним в папке typings в корне проекта в файле  app.typings.ts(x)
- Не используем тип any.
- Не используем подавление ошибок типа через оператор ``!``.
- Стараемся не использовать оператор ``as``, а вместо него применяем проверку типов [type guard](https://medium.com/@eqbits/%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-type-guards-%D0%B2-typescript-24834d2b4f). 
  - Для классов\обьектов через ``instanceof``
  - Для литералов через ``typeof``
- Не используем ``// @ts-ignore``, а пишем ``// @ts-expect-error <причина ошибки>``

### Архитектура
- Придерживаемся [трехслойной архитектуры](https://doka.guide/js/clean-architecture/). Основное: разделяем бизнес-логику, графический интерфейс и сетевые запросы. 
- Помним про базовые принципы разработки ПО:
  - DRY – Don’t repeat yourself – принцип призывает Вас не повторяться при написании кода. Все что Вы пишите в проекте, должно быть определено только один раз.
  - KISS – keep it short simple – делайте вещи проще. Порой наиболее правильное решение – это наиболее простая реализация задачи, в которой нет ничего лишнего.
  - YAGNI — You ain’t gonna need it – вам это не понадобится. Все что не предусмотрено техническим заданием проекта, не должно быть в нем. Речь главным образом про такое явление, как "код на будущее", который может быть понадобится, а может быть и нет.

### Нейминг
- Про нейминг [тут](https://habr.com/ru/post/488378/) вкратце описано. Стараемся соответствовать. 
  - Проверки чего-либо начинаются с is или has.
  - Функции начинаются с глаголов (по возможности).
  - Длинное, но понятное наименование лучше короткого и непонятного.

### Убираем магию
- Стараемся избегать "магии" в коде. Т.е. код типа ``let someVar = anotherVar * 60`` - это плохой код. Что такое 60? Неизвестно, какое-то магическое число. Такие вещи нужно выносить в переменные/константы.
- Строковую "магию" тоже стараемся не создавать. ``let someVar = anotherVar + '/some-path'`` - потенциально плохой код. Если '/somePath' используется в нескольких местах и возникнет потребность его изменить, то это создаст приличный объем работы и потенциальный риск ошибок. Лучше вынести строку в переменную/константу, и тогда поменять путь нужно будет только в одном месте, где эта константа/переменная определена.

### Делаем код понятнее
- Стоит выносить в переменные длинные условия вроде таких:
```javascript
if(somevar && !anotherVar && typeof checkSomething(arg) === 'number') {...}
```

Лучше это превратить в такое:
  
  ```javascript
  let isSomeCheckName = somevar && !anotherVar && typeof checkSomething(arg) === 'number';
  
  if(isSomeCheckName) {...}
  ```

В итоге по названию переменной сразу понятно что здесь проверяется и, возможно, даже зачем. Это сэкономит время на анализе условий.

### React
- Файлы компонентов и страниц именуем с большой буквы в стиле PascalCase.
- Styleguide - [React: лучшие практики](https://habr.com/ru/post/541320/)
  
### Redux

- [Официальный styleGuide](https://redux.js.org/style-guide/#structure-files-as-feature-folders-with-single-file-logic) с хорошими практиками.