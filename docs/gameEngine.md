# Игровой движок Tanchiki (Battle City / Tank N 1990)

- [Базовые классы](#базовые-классы)
  - [Game](#game)
  - [Zone](#zone)
  - [View](#view)
  - [Controller](#controller)
  - [Entity](#entity)
  - [Terrain](#terrain)
  - [DynamicEntity](#dynamicentity)
  - [Tank](#Tank)
  - [Projectile](#Projectile)
- [Вспомогательные классы](#вспомогательные-классы)
  - [EventBus](#eventbus)
- [Будущие классы](#будущие-классы)
  - [User](#user)
  - [Overlay](#overlay)
  - [Flag](#flag)
  - [Scenario](#scenario)
  - [Sound](#sound)
  - [PowerUp](#powerup)
  - [EnemyAI](#enemyai)

---

![Game engine demo](img/GameEngineDemo1.gif)

---

## Базовые классы

### Game

Основной сервис, в котором запускается игровой цикл (loop) и инициализируются все основные игровые сервисы и объекты. Цикл работает с заданным интервалом (loopTimeMs), перебирая массив объектов (loopEntities), в которых отслеживаются изменения.

### Zone

Сервис игровой зоны, который содержит матрицу (двумерный массив 52х52) - карту местности, где указано расположение всех игровых объектов. Их нужно зарегистрировать (registerEntity), чтобы данные о них автоматически обновлялись (через подписки на события). Выполняет проверку на столкновение объектов (hasCollision).

### View

Графический сервис. Содержит пять наложенных друг на друга канвасов (слоёв), на которых отрисовываются разные типы объектов. Их нужно зарегистрировать на нужном слое (bindEntityToLayer), чтобы они автоматически перерисовывались при изменениях (обновление через подписки на события). 

*Пока что используются цветные прямоугольники, нужно будет потом приделать изображения в виде спрайтов.*

### Controller

Сервис управления. Ловит нажатия клавиш на клавиатуре (две раскладки - WASD+пробел или стрелки+энтер), которые затем можно снять через соответствующие события.

*Нужно будет потом добавить поддержку других контроллеров (виртуальные кнопки, джостики).*

### Entity

Абстрактная игровая сущность, от которой наследуются все остальные. Содержит общие для всех методы и свойства, связанные с жизненным циклом и позиционированием. Основные:
  - shouldBeDestroyed: должен ли объект быть уничтожен (проверяется в игровом цикле Game);
  - direction: в какую сторону смотрит объект;
  - movable: динамический или статический объект;
  - flying: летящий тип (для снарядов);
  - crossable: можно ли переезжать через сущность (к примеру, через деревья - можно);
  - hittable: можно ли попасть в сущность снарядом (в воду и деревья - нельзя);
  - alignedToGrid: стоит ли объект ровно по сетке в соответствии с матрицей Zone (для отрисовки плавных движений объект может иметь дробные координаты);
  - lastRect: прямоугольник, где находился объект до начала движения;
  - nextRect: прямоугольник, куда собирается двигаться объект;
  - spawned: находится ли объект в игре;
  - setState(): обновляет состояние объекта и запускает события, которые отлавливаются в других сервисах;
  - getRect(): возвращает прямоугольник, в котором находится объект;
  - spawn(): размещает объект по заданным координатам;
  - despawn(): убирает объект из игры.

### Terrain

Статические сущности (стены, вода, деревья). 

*Нужно будет сделать механику разрушения стен.*

### DynamicEntity

Абстрактная игровая сущность, которая может двигаться (от неё наследуются танки и снаряды). Содержит свойства и методы, связанные с движением. Основные:
  - moving: должен ли объект двигаться;
  - stopping: прекращает ли объект движение (он должен стать по целочисленным координатам);
  - canMove: может ли объект двигаться дальше;
  - movePace: на сколько клеток за раз перемещается объект;
  - moveSpeed: скорость движения объекта;
  - moveStepsTotal: за сколько игровых циклов объект совершает один ход;
  - moveStepsProgress: сколько игровых циклов хода пройдено;
  - nextDirection: новое направление, по которому объект начнёт движение после завершения полного хода;
  - getMoveSteps(): рассчитывает количество игровых циклов для одного хода с поправкой на скорость;
  - getMoveStepPace(): рассчитывает расстояние, на которое объект пересместится за один игровой цикл;
  - act(): вызывается в каждом игровом цикле для определения необходимости двигаться; 
  - stop();
  - turn();
  - turnStep(): чтобы объект не начал двигаться сразу после поворота;
  - move();
  - prepareToMove(): выполняет проверку на то, может ли объект двигаться дальше;
  - getNextMove(): рассчитывает координаты следующего хода;
  - moveStep(): выполняет микродвижение за игровой цикл;
  - moveStepCheck(): выполняет проверку в каждом игровом цикле (нужна для снарядов).

### Tank

Танк:
 - shoot();
 - calculateProjectilePos(): высчитывает стартовую позицию снаряда.

*Нужно будет сделать функционал для ограничения количества выпускаемых снарядов.*

### Projectile

Снаряд:
  - shouldExplode: даёт дополнительный игровой цикл жизни снарядам, чтобы они могли взрываться друг об друга.

---

## Вспомогательные классы

### EventBus

Взят из первого модуля. От него наследуются ряд классов для реализации функционала подписок на события.

---

## Будущие классы

### User

*Класс игрока. Функционал начисления очков.*

### Overlay

*Модальные окна (название предстоящего уровня, пауза, подсчёт очков).*

### Flag

*Штаб, при разрушении которого игра заканчивается.*

### Scenario

*Игровой сценарий.*

### Sound

*Звуковой сервис.*

### PowerUp

*Бонусы.*

### EnemyAI

*Вражеский ИИ.*
